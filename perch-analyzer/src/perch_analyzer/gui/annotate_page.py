import gradio as gr
from dataclasses import dataclass
from perch_analyzer.config import config
from perch_analyzer.db import db
from perch_analyzer.examine import examine_annotations, audio_windows
from perch_hoplite.db import sqlite_usearch_impl, interface
from ml_collections import config_dict


@dataclass
class WindowDisplayData:
    filename: str
    target_label: str
    offsets: str
    spec_file: str
    recording_file: str
    window: examine_annotations.WindowWithAnnotations


@dataclass
class UIUpdate:
    """Represents an update to all UI components."""

    filename: str
    target_label: str
    offsets: str
    spec_file: str | None
    recording_file: str | None
    dropdown_value: list[str]
    dropdown_choices: list[str]
    window: examine_annotations.WindowWithAnnotations | None


def get_next_example_to_annotate(
    hoplite_db: sqlite_usearch_impl.SQLiteUSearchDB,
) -> examine_annotations.WindowWithAnnotations | None:
    annotations = hoplite_db.get_all_annotations(
        config_dict.create(eq=dict(label_type=interface.LabelType.POSSIBLE))
    )

    # there are no examples to annotate
    if len(annotations) == 0:
        return None

    annotation = annotations[0]

    recording = hoplite_db.get_recording(annotation.recording_id)
    windows = hoplite_db.get_all_windows(
        filter=config_dict.create(
            eq=dict(recording_id=recording.id), approx=dict(offsets=annotation.offsets)
        )
    )

    if len(windows) != 1:
        raise ValueError(
            f"ut oh, there are multiple (or zero) windows with the same offsets and recording id, {len(windows)}"
        )

    return examine_annotations.WindowWithAnnotations(
        recording=recording, window=windows[0], annotations=[annotation]
    )


def make_annotation(
    config: config.Config,
    hoplite_db: sqlite_usearch_impl.SQLiteUSearchDB,
    new_labels: list[str],
    window: examine_annotations.WindowWithAnnotations,
) -> None:
    # first remove the existing annotation generated by the search
    if hoplite_db.get_annotation(window.annotations[0].id):
        hoplite_db.remove_annotation(window.annotations[0].id)

    # then add the new annotations
    examine_annotations.update_labels(
        config=config,
        hoplite_db=hoplite_db,
        window_id=window.window.id,
        new_labels=new_labels,
    )

    hoplite_db.commit()


def get_window_display_data(
    config: config.Config,
    hoplite_db: sqlite_usearch_impl.SQLiteUSearchDB,
    window: examine_annotations.WindowWithAnnotations,
) -> WindowDisplayData:
    """Helper to get display data for a window."""
    recording_file, spec_file = audio_windows.get_audio_window_path(
        config=config, hoplite_db=hoplite_db, window_id=window.window.id
    )
    return WindowDisplayData(
        filename=f"## Filename: {window.recording.filename}",
        target_label=f"## Target recording label: {window.annotations[0].label}",
        offsets=f"### Offsets: {window.window.offsets}",
        spec_file=str(spec_file),
        recording_file=str(recording_file),
        window=window,
    )


def annotate() -> :
    def submit_annotations(
        labels: list[str], current_window: examine_annotations.WindowWithAnnotations
    ) -> UIUpdate:
        # Create new DB connection for this thread
        thread_hoplite_db = sqlite_usearch_impl.SQLiteUSearchDB.create(
            f"{config.data_path}/{config.hoplite_db_path}"
        )

        # Filter out empty labels
        filtered_labels = [label.strip() for label in (labels or []) if label.strip()]

        make_annotation(config, thread_hoplite_db, filtered_labels, current_window)

        # Get updated label list after annotation
        updated_labels = thread_hoplite_db.get_all_labels()

        # Get the next window to annotate
        next_window = get_next_example_to_annotate(hoplite_db=thread_hoplite_db)

        if next_window is None:
            return UIUpdate(
                filename="## No more windows to annotate!",
                target_label="",
                offsets="",
                spec_file=None,
                recording_file=None,
                dropdown_value=[],
                dropdown_choices=list(updated_labels),
                window=None,
            )

        display_data = get_window_display_data(config, thread_hoplite_db, next_window)
        return UIUpdate(
            filename=display_data.filename,
            target_label=display_data.target_label,
            offsets=display_data.offsets,
            spec_file=display_data.spec_file,
            recording_file=display_data.recording_file,
            dropdown_value=[],
            dropdown_choices=list(updated_labels),
            window=display_data.window,
        )

    next_window = get_next_example_to_annotate(hoplite_db=hoplite_db)

    with gr.Blocks() as annotate_blocks:
        if next_window is None:
            gr.Markdown("no more windows to annotate!")
            return annotate_blocks

        display_data = get_window_display_data(config, hoplite_db, next_window)
        all_labels = hoplite_db.get_all_labels()

        next_window_state = gr.State(value=next_window)

        with gr.Row():
            with gr.Column(scale=1):
                filename_md = gr.Markdown(display_data.filename)
                target_label_md = gr.Markdown(display_data.target_label)
                offsets_md = gr.Markdown(display_data.offsets)

                new_labels = gr.Dropdown(
                    all_labels,
                    multiselect=True,
                    allow_custom_value=True,
                    label="Select Labels",
                )

                submit_button = gr.Button("Submit annotations!")
            with gr.Column(scale=2):
                image_display = gr.Image(
                    display_data.spec_file, height=400, container=False
                )
                audio_display = gr.Audio(
                    display_data.recording_file,
                    label="Audio",
                    container=False,
                    show_label=False,
                )

        # We need to update dropdown separately to handle both value and choices
        def update_ui(
            labels: list[str], window: examine_annotations.WindowWithAnnotations
        ) -> tuple:
            update = submit_annotations(labels, window)
            return (
                update.filename,
                update.target_label,
                update.offsets,
                update.spec_file,
                update.recording_file,
                gr.Dropdown(
                    value=update.dropdown_value, choices=update.dropdown_choices
                ),
                update.window,
            )

        submit_button.click(
            fn=update_ui,
            inputs=[new_labels, next_window_state],
            outputs=[
                filename_md,
                target_label_md,
                offsets_md,
                image_display,
                audio_display,
                new_labels,
                next_window_state,
            ],
        )

    return annotate_blocks
